<style>
    div.tooltip {
        position: relative;
        text-align: center;
        width: 130px;
        height: 75px;
        padding: 5px;
        font: 12px sans-serif;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }
</style>

<script>

    /*
     Author: Ryan Habibi
     Date: Jan 2015
     Bar Graph (Histogram) Visualization

     Generates a bar graph with three bars, used to show comparisons of at a single point in time.
     */

    var colorMap = {clinician: 'lightSlateGray', group: 'royalBlue', network: 'lightCoral'};
    //@WiP create the tooltip div
    var div = d3.select("#chart").append("div")
            .attr("class", "tooltip")
            .style({"opacity": 0, "width": "150"});

    var formatTime = d3.time.format("%Y-%m-%d");

    function toolTipMouseOver(d, src, name) {

        var units = d.units || "Patients";
        //var p = $(".container").position();
        var p = $("svg").offset();

        div.transition()
                .duration(200)
                .style("opacity", 0.9);
        div.html(
                name + "<br/>" +
                "Date: " + formatTime(new Date(d.time * 1000)) + "<br/>" +
                "Ratio: " + ( (d.aggregate_result.numerator / d.aggregate_result.denominator ) * 100).toFixed(2) + " %<br/>" +
                "Num of "+units+": " + d.aggregate_result.numerator + "<br/>" +
                "Total "+units+": " + d.aggregate_result.denominator)
                .style("background", colorMap[src])
                .style("top", (d3.event.pageY - p.top) + "px")
                .style("left", (d3.event.pageX - p.left + 100) + "px");
    }

    function toolTipMouseOut(d) {
        div.transition()
                .duration(500)
                .style("opacity", 0);
    }

    function vis(data) {

        console.log(data);

        var dataCopy = (JSON.parse(JSON.stringify(data)));

        //use only last point
        data.processed_result.clinician = data.processed_result.clinician.slice(-1);
        data.processed_result.group     = data.processed_result.group.slice(-1);
        data.processed_result.network   = data.processed_result.network.slice(-1);

        //define container constraints
        var margin = {top: 50, right: 50, bottom: 75, left: 75},
            width  = 600 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        //set up SVG container to contain all components
        var canvas = d3.select("#chart")
                .append("svg:svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("svg:g")
                .attr("transform", "translate(" + margin.left + ", 10) scale(0.90, 0.90)");

        //append a title

        tmpXScale = [
            data.processed_result.network[0].display_name,
            data.processed_result.group[0].display_name,
            data.processed_result.clinician[0].display_name
        ];

        //x position scale using date data
        //domain set as the first 3 keys in the JSON,
        //if structure modified must be changed.
        var xScale = d3.scale.ordinal()
                .rangeBands([0, width], 0.1)
                .domain(tmpXScale);

        //x axis scale
        var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient("bottom");

        //add X Axis to canvas
        canvas.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis)
                .append("text")
                .attr("x", (width ) / 2)
                .attr("y", margin.bottom + 50)
                .style({"text-anchor": "middle", "font-size": "14pt"})
                .text("Perspective");

        //Rotate and move X Axis ticks for vertical write and align
        canvas.selectAll("g.x.axis g.tick text")
                .style({"text-anchor": "end", "font-size": "14pt"})
                .attr("dx", "-0.5em")
                .attr("dy", "1em")
                .attr("transform", "rotate(-45)");

        //y position scaling
        var yScale = d3.scale.linear()
                .range([height, 0]);

        //function to return a ratio rounded up to the nearest 10
        //used for scaling Y Axis
        var trimAndScale = function (d) {

            var x = d.aggregate_result.numerator / d.aggregate_result.denominator;
            x     = Math.ceil((x * 10) + 1) * 10;
            if (x > 100) {
                return 100;
            } else {
                return x;
            }
        };

        //scale Y axis based on global maximum
        //ineffecient. Could retieve local maxs and trimAndScale just those values
        yScale.domain([0, d3.max([
            d3.max(data.processed_result.network, trimAndScale),
            d3.max(data.processed_result.group, trimAndScale),
            d3.max(data.processed_result.clinician, trimAndScale)
        ])]);

        //y axis def
        var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient("left");

        var units = data.units || "Patients";

        //add Y Axis to canvas
        canvas.append("g")
                .attr("class", "y axis")
                .attr("transform", "translate(6,0)")
                .style({"text-anchor": "middle", "font-size": "14pt"})
                .call(yAxis)
                .append("text")
                .attr("y", -40)
                .attr("x", -height / 2 + margin.top)
                .attr("transform", "rotate(-90) translate(-50, 0)")
                .style({"text-anchor": "middle", "font-size": "14pt"})
                .text(units+" (%)");

        //Bars(rects) for display. Due to JSON formatting the easiest way is
        //to create them seperatly.

        function getDelta(d) {
            if (d.aggregate_result.denominator === 0) {
                return height;
            }
            else {
                return yScale((d.aggregate_result.numerator / d.aggregate_result.denominator) * 100);
            }
        }

        var bar3 = canvas.append("g")
                .attr("class", "bars")
                .selectAll(".bar")
                .data(data.processed_result.clinician)
                .enter().append("rect")
                .attr("x", xScale(data.processed_result.clinician[0].display_name))
                .attr("y", yScale(0))
                .attr("width", xScale.rangeBand())
                .attr("height", 0)
                .attr("fill", "black")
                .attr("height",
                function (d) {
                    return height - getDelta(d);
                })
                .attr("y", function (d) {
                    return getDelta(d);
                })
                .on("mouseover", function (d) {
                    toolTipMouseOver(d, 'clinician', data.processed_result.clinician[0].display_name);
                })
                .on("mouseout", toolTipMouseOut);

        var bar2 = canvas.append("g")
                .attr("class", "bars")
                .selectAll(".bar")
                .data(data.processed_result.group)
                .enter().append("rect")
                .attr("x", xScale(data.processed_result.group[0].display_name))
                .attr("y", yScale(0))
                .attr("width", xScale.rangeBand())
                .attr("height", 0)
                .attr("fill", "steelblue")
                .attr("height", function (d) {
                    return height - getDelta(d);
                })
                .attr("y", function (d) {
                    return getDelta(d);
                })
                .on("mouseover", function (d) {
                    toolTipMouseOver(d, 'group', data.processed_result.group[0].display_name);
                })
                .on("mouseout", toolTipMouseOut);

        var bar1 = canvas.append("g")
                .attr("class", "bars")
                .selectAll(".bar")
                .data(data.processed_result.network)
                .enter().append("rect")
                .attr("x", xScale(data.processed_result.network[0].display_name))
                .attr("y", yScale(0))
                .attr("width", xScale.rangeBand())
                .attr("height", 0)
                .attr("fill", "red")
                .attr("y", function (d) {
                    return getDelta(d);
                })
                .attr("height", function (d) {
                    return height - getDelta(d);
                })
                .on("mouseover", function (d) {
                    toolTipMouseOver(d, 'network', data.processed_result.network[0].display_name);
                })
                .on("mouseout", toolTipMouseOut);

        //mapping for colour selection and legend
        var colorMap = {network: "red", group: "steelblue", clinician: "black"};

        //size for colour suqares in legend
        var legendRectSize = 15;
        //shift value for each legend entry
        var legendSpacing = 20;

        var legendWidth  = 180;
        var legendHeight = 65;
        //add a container for the legend
        var legend = canvas.append('g')
                .attr('class', 'legend')
                .attr("transform", "translate(" + (width - legendWidth / 2 - 5) + ", -5)");

        //append a background for the legend
        legend.append('rect')
            //transform neg-ive so the left and top are around the legend item
                .attr('width', legendWidth)  //values chosen based on info being displayed
                .attr('height', legendHeight)
                .style('fill', "white");

        //create legend entires and for each add a colour block and text
        legend.selectAll('.legendEntry')
                .data(Object.keys(colorMap))
                .enter().append("g")
                .attr('class', 'legendEntry')
                .attr("transform", function (d, i) {
                    return "translate(0," + legendSpacing * i + ")";
                })
                .call(function (d) {

                    //append entry text
                    d.append('text')
                            .style({"text-anchor": "start", "text-decoration": "none", "font-size": "14pt"})
                            .text(function (d) {
                                return data.processed_result[d][0].display_name;
                            })
                            .attr("transform", function (d, i) {
                                return "translate(" + (legendRectSize * 1.5 + 10) + ",17)";
                            });

                    //append colour square
                    d.append('rect')
                            .attr('width', legendRectSize)
                            .attr('height', legendRectSize)
                            .attr("transform", "translate(5, 5)")
                            .style('fill', function (d) {
                                return colorMap[d];
                            })
                            .style('stroke', function (d) {
                                return colorMap[d];
                            });
                });
    }
</script>

<style>

  .axis path,
  .axis line {
    stroke: Black;
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
  }

  div.tooltip {
    position: absolute;
    text-align: center;
    width: 125px;
    height: 40px;
    padding: 2px;
    font: 12px sans-serif;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
  }
</style>

<script>
    /*
        Author: Ryan Habibi
        Date: Jan 2015

        Line Graph Visualization

        Creates an SVG object containing x and y axis, title, and generating 3 lines
        out of data points provided in the JSON for network, clinic, and clinician.
    */
    var colorMap = {clinician: 'lightSlateGray', clinic: 'royalBlue', network: 'lightCoral'};
    //@WiP create the tooltip div
    var div = d3.select("#chart").append("div")
    .attr("class", "tooltip")
    .style({"opacity":0, "width":"150"});

    var formatTime = d3.time.format("%a %b %d %Y");

    function toolTipMouseOver(d, src)
    {
        div.transition()
        .duration(200)
        .style("opacity", 0.9);
        div.html(
          "Date: "+ formatTime(d.time) + "<br/>" +
          "Num of Patients:" + d.aggregate_result.numerator + "<br/>" +
          "Total Patients:" + d.aggregate_result.denominator)
        .style({"left": (d3.event.pageX) + "px",
                "top": (d3.event.pageY - 28) + "px",
                "background":colorMap[src]});
    }

    function toolTipMouseOut(d)
    {
      div.transition()
      .duration(500)
      .style("opacity", 0);
    }

    //data needs to be valid JSON in standard HUB API line graph format
    function vis(data){

        //define container constraints
        var margin = {top: 50, right: 50, bottom: 150, left: 75},
            width = 600 - margin.left - margin.right,
            height = 200 - margin.top + margin.bottom;

        //expected date format for parsing to data types
        var parseDate = d3.time.format("%a %b %d %Y").parse;

        //x position scale using date data
        var xScale = d3.time.scale()
            .range([0,width]);

        //y position scaling
        var yScale = d3.scale.linear()
            .range([height,0]);

        //x axis def
        var xAxis = d3.svg.axis()
            .scale(xScale)
            .orient("bottom");

        //y axis def
        var yAxis = d3.svg.axis()
            .scale(yScale)
            .orient("left");

        //set up SVG container to contain all components,
        //all further elements are appended to he canvas to be seen
        var canvas = d3.select("#chart")
            .append("svg")
            .attr("width",width + margin.left + margin.right)
            .attr("height",height + margin.top + margin.bottom)
            .append("svg:g")
            .attr("transform", "translate(20,0)");

        //append title text to the top of the page
        canvas.append("g")
            .attr("class", "title")
            .append("text")
            .attr("x", width/2 + 60)
            .attr("y", margin.top/2)
            .style({"text-anchor":"middle", "text-decoration":"underline", "font-size":"14pt"})
            .text(data.description);


        //Line functions to build path from JSON data
        var line = d3.svg.line()
            .x(function(d){return xScale(d.time);})
            .y(function(d){return yScale((d.aggregate_result.numerator/d.aggregate_result.denominator)*100);});

        //parse date on all line data to standardize format as outlined in above parse function
        data.processed_result.network.forEach(function(d) {
            d.time = parseDate(d.time);
        });
        data.processed_result.clinic.forEach(function(d) {
            d.time = parseDate(d.time);
        });
        data.processed_result.clinician.forEach(function(d) {
            d.time = parseDate(d.time);
        });

        //scale number of XAxis ticks based on JSON
        //causes some problems because of automatic D3 tick labels, could be changed with stronger logic
        xAxis.ticks(Math.max(
            Object.keys(data.processed_result.network).length,
            Object.keys(data.processed_result.clinic).length,
            Object.keys(data.processed_result.clinician).length
        ));

        //set the domain to the absolute min and max of the 3 data sets to ensure proper scaling
        xScale.domain([
            d3.min([
                d3.min(data.processed_result.network,function(d){return d.time;}),
                d3.min(data.processed_result.clinic,function(d){return d.time;}),
                d3.min(data.processed_result.clinician,function(d){return d.time;})
            ]),
            d3.max([
                d3.max(data.processed_result.network,function(d){return d.time;}),
                d3.max(data.processed_result.clinic,function(d){return d.time;}),
                d3.max(data.processed_result.clinician,function(d){return d.time;})
            ])
        ]);

        //function to return a ratio rounded up to the nearest multiple of 10
        //used for scaling Y Axis
        var trimAndScale = function(d) {
          var x;
          x = d.aggregate_result.numerator/d.aggregate_result.denominator;
          x = Math.ceil((x*10)+1)*10;

          if (x > 100){
              return 100;
          } else {
              return x;
          }
        };

        //scale Y axis
        //ineffeicent, should find local maximums and trimAndScale just those values
        yScale.domain([0,d3.max([
            d3.max(data.processed_result.network,trimAndScale),
            d3.max(data.processed_result.clinic,trimAndScale),
            d3.max(data.processed_result.clinician,trimAndScale)
        ])]);

        //add X Axis to canvas
        canvas.append("g")
            .attr("class", "xaxis")
            .attr("transform", "translate(60," + (height + 45) + ")")
            .call(xAxis)
            .append("text")
                .attr("x", width/2)
                .attr("y", margin.bottom - 70 )
                .style("text-anchor","middle")
                .text("Query Date");

        //add Y Axis to canvas
        canvas.append("g")
            .attr("class", "yaxis")
            .attr("transform", "translate(60," + (margin.top/2 + 26) + ")")
            .call(yAxis)
            .append("text")
                .attr("y", -40)
                .attr("x", -height/2 + margin.top)
                .attr("transform", "rotate(-90) translate(-20,0)")
                .style({"text-anchor":"middle", "font-size":"12pt"})
                .text("Percentage of Patients (%)");

        //rotate and move Y Axis ticks for vertical write and align
        canvas.selectAll("g.yaxis g.tick text")
        .style({"text-anchor":"start", "font-size":"12pt"})
        .attr("dx", "-20px")
        .attr("dy", "0px");

        //rotate and move X Axis ticks for vertical write and align
        canvas.selectAll("g.xaxis g.tick text")
        .style({"text-anchor":"start", "font-size":"12pt"})
        .attr("dx", ".8em")
        .attr("dy", "-.35em")
        .attr("transform", "rotate(90)");

        //create and append paths using line data
        if(data.processed_result.clinician.length>1)
        {
          var clinicianPath = canvas.append("g")
          .attr("class","line")
          .selectAll("path")
          .data([data.processed_result.clinician])
          .enter().append("path")
              .attr("d", line)
              .attr("fill", "none")
              .attr("stroke", "black")
              .attr("stroke-width",5)
              .attr("transform", "translate(60," + (margin.top/2 + 20) + ")");
        }

        if(data.processed_result.clinic.length>1)
        {
          var clinicPath = canvas.append("g")
          .attr("class","line")
          .selectAll("path")
          .data([data.processed_result.clinic])
          .enter().append("path")
              .attr("d", line)
              .attr("fill", "none")
              .attr("stroke", "blue")
              .attr("stroke-width",2)
              .attr("transform", "translate(60," + (margin.top/2 + 20) + ")");
        }

        if(data.processed_result.clinician.length>1)
        {
          var networkPath = canvas.append("g")
              .attr("class","line")
              .selectAll("path")
              .data([data.processed_result.network])
              .enter().append("path")
                  .attr("d", line)
                  .attr("fill", "none")
                  .attr("stroke", "red")
                  .attr("stroke-width",1)
                  .attr("transform", "translate(60," + (margin.top/2 + 20) + ")");
        }
        
        function getDelta(d)
    		{
    			if(d.aggregate_result.denominator === 0)
    			{
    				return height;
    			}
    			else
    			{
    				return yScale((d.aggregate_result.numerator/d.aggregate_result.denominator)*100);
    			}
    		}

        //add circles for points to make clear when there is a recorded value
        var clinicianPoints = canvas.append("g")
        .attr("class","points")
        .selectAll("circle")
        .data(data.processed_result.clinician)
        .enter().append("circle")
            .attr("onmouseover", "evt.target.setAttribute('r', '10');")
            .attr("onmouseout", "evt.target.setAttribute('r', '7');")
            .attr("cx",function(d){return xScale(d.time);})
            .attr("cy",function(d){return getDelta(d);})
            .attr("fill","black")
            .attr("r",7)
            .attr("transform", "translate(60," + (margin.top/2 + 20) + ")")
            .on("mouseover", function (d){toolTipMouseOver(d, 'clinician');})
            .on("mouseout", toolTipMouseOut);

        var clinicPoints = canvas.append("g")
        .attr("class","points")
        .selectAll("circle")
        .data(data.processed_result.clinic)
        .enter().append("circle")
            .attr("onmouseover", "evt.target.setAttribute('r', '10');")
            .attr("onmouseout", "evt.target.setAttribute('r', '5');")
            .attr("cx",function(d){return xScale(d.time);})
            .attr("cy",function(d){return getDelta(d);})
            .attr("fill","blue")
            .attr("r",4)
            .attr("transform", "translate(60," + (margin.top/2 + 20) + ")")
            .on("mouseover", function (d){toolTipMouseOver(d, 'clinic');})
            .on("mouseout", toolTipMouseOut);

        var networkPoints = canvas.append("g")
            .attr("class","points")
            .selectAll("circle")
            .data(data.processed_result.network)
            .enter().append("circle")
                .attr("onmouseover", "evt.target.setAttribute('r', '10');")
                .attr("onmouseout", "evt.target.setAttribute('r', '2');")
                .attr("cx",function(d){return xScale(d.time);})
                .attr("cy",function(d){return getDelta(d);})
                .attr("fill","red")
                .attr("r",2)
                .attr("transform", "translate(60," + (margin.top/2 + 20) + ")")
                .on("mouseover", function (d){toolTipMouseOver(d, 'network');})
                .on("mouseout", toolTipMouseOut);

        //mapping for colour selection and legend
        var colorMap = {network:"red", clinic:"blue", clinician:"black"};

        //size for colour suqares in legend
        var legendRectSize = 16;
        //shift value for each legend entry
        var legendSpacing = 20;

        var legendWidth = 180;
        var legendHeight = 86;
        //add a container for the legend
        var legend = canvas.append('g')
        .attr('class', 'legend')
        .attr("transform","scale(0.5, 0.5) translate(" + (width*2 - 20) + ", 100)");

        //append a background for the legend
        legend.append('rect')
        //transform neg-ive so the left and top are around the legend item
        .attr('width', 180)  //values chosen based on info being displayed
        .attr('height', 65)
        .style('fill', "lightgrey");

        //create legend entires and for each add a colour block and text
        legend.selectAll('.legendEntry')
        .data(Object.keys(colorMap))
        .enter().append("g")
        .attr('class', 'legendEntry')
        .attr("transform",function(d,i){return "translate(0," + legendSpacing*i +")";})
        .call(function(d){

          //append entry text
          d.append('text')
          .style({"text-anchor":"start","text-decoration":"underline", "font-size":"14pt"})
          .text(function(d) { return d; })
          .attr("transform",function(d,i){return "translate(" + (legendRectSize*1.5 + 10) + ",17)";});

          //append colour square
          d.append('rect')
          .attr('width', legendRectSize)
          .attr('height', legendRectSize)
          .attr("transform", "translate(5, 5)")
          .style('fill', function(d){return colorMap[d];})
          .style('stroke', function(d){return colorMap[d];});
        });
    }
</script>
